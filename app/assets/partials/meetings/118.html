
<div>
  <div page="1" class="section">
    <div class="centered">
      <div class="container">
        <div class="row">
          <div class="span12">
            <h4>118 spotkanie WJUGa</h4>
            <h2>Java Memory Model</h2>
            <h3>Michał Warecki</h3>
            <p>Termin: 06.18.2013 godz. 18:00</p>
            <p>Lokalizacja: MIMUW,</p>
            <p>Zapisy i dyskusja:<a href="http://www.meetup.com/Warszawa-Java-User-Group-Warszawa-JUG/events/123604012/" target="_blank"> Meetup</a></p><strong>Materiały:</strong>
            <ul>
              <li><a href="https://docs.google.com/file/d/0B8d787eZJXI_YVNWMml2dEVzeVE/edit?usp=sharing" target="_blank"> plakat</a></li>
              <li><a href="http://www.slideshare.net/michalwarecki/java-memory-model-23207253" target="_blank"> slajdy</a></li>
              <li><a href="https://github.com/michalwarecki/java-memory-model" target="_blank"> kod źródłowy</a></li>
            </ul>
            <h3>O prezentacji:</h3>
            <p>Java Memory Model (JMM) opisuje jak wątki współdziałają ze sobą poprzez pamięć. Czy wiesz, że instrukcje Twojego kodu mogą się wykonać w innej kolejności niż je napisałeś? Czy wiesz, że kilka wątków może widzieć zupełnie inną wartość tej samej zmiennej? Czy wiesz, że możesz mieć na to wpływ?</p>
            <p>Głównymi pojęciami wchodzącymi w skład JMM są: zmiana kolejności instrukcji, niepodzielność (atomowość) oraz widzialność. Aby pokazać jak to wszystko działa, sięgnę aż do instrukcji maszynowych generowanych przez HotSpot JVM.</p>
            <h3>O prelegencie:</h3>
            <p>Michał jest programistą skupiającym się na technologiach opartych o JVM. Jego głównymi obszarami zainteresowań są:</p>
            <ul>
              <li>algorytmy GC,</li>
              <li>współbieżność,</li>
              <li>algorytmy wolne od blokad,</li>
              <li>kompilatory typu JIT.</li>
            </ul>
            <p>Tworząc oprogramowanie pamięta jak zbudowane są współczesne procesowy, pamięć fizyczne oraz system operacyjny. Nie ogranicza się tylko do poziomu bytecode'u lecz obserwuje także wewnętrzne komponenty OpenJDK oraz kod maszynowy przez nie generowany.</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>